# -*- coding: utf-8 -*-
"""Neuro240 Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10HhL-D3TnTTKNd9XcznUHzbYcBw16MNl
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from dataclasses import dataclass
from typing import List, Dict, Optional
import torch
import torch.nn as nn
from bindsnet.network import Network
from bindsnet.network.nodes import Input, LIFNodes, AdaptiveLIFNodes
from bindsnet.network.topology import Connection
from bindsnet.learning import PostPre, MSTDP
from bindsnet.network.monitors import Monitor
from bindsnet.analysis.plotting import plot_spikes, plot_voltages
from datetime import datetime
import random
import os
import seaborn as sns
from sklearn.model_selection import train_test_split, KFold
from bindsnet.network.nodes import Input, LIFNodes, AdaptiveLIFNodes
from bindsnet.network.topology import Connection
from bindsnet.learning import MSTDP, PostPre
from bindsnet.analysis.plotting import plot_spikes, plot_voltages
from typing import List, Tuple, Dict
from dataclasses import dataclass
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import TensorDataset, DataLoader
import matplotlib.gridspec as gridspec
from torch import tensor

@dataclass
class TradePosition:
    entry_price: float
    entry_date: datetime
    position_type: str  # 'long' or 'short'
    size: int
    exit_price: float = None
    exit_date: datetime = None
    pnl: float = None

class PortfolioMetrics:
    """
    Class to track portfolio performance metrics
    """
    def __init__(self, initial_capital=100000.0):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.current_position = None
        self.trades = []
        self.daily_capital = []
        self.daily_returns = []
        self.trade_count = 0
        self.winning_trades = 0
        self.total_pnl = 0.0
    
    def open_position(self, price, date, position_type, size=1.0):
        """
        Open a new trading position
        
        Args:
            price (float): Entry price
            date (datetime): Entry date
            position_type (str): Either 'long' or 'short'
            size (float): Position size (default=1.0)
        """
        if self.current_position is not None:
            self.close_position(price, date)
        
        self.current_position = TradePosition(
            entry_price=price,
            entry_date=date,
            position_type=position_type,
            size=size
        )
    
    def close_position(self, price, date):
        """
        Close the current trading position
        
        Args:
            price (float): Exit price
            date (datetime): Exit date
        """
        if self.current_position is None:
            return
        
        # Calculate PnL
        if self.current_position.position_type == 'long':
            pnl = (price - self.current_position.entry_price) * self.current_position.size
        else:  # short
            pnl = (self.current_position.entry_price - price) * self.current_position.size
        
        # Update metrics
        self.current_capital += pnl
        self.total_pnl += pnl
        self.trade_count += 1
        if pnl > 0:
            self.winning_trades += 1
        
        # Record trade
        self.trades.append({
            'entry_date': self.current_position.entry_date,
            'exit_date': date,
            'entry_price': self.current_position.entry_price,
            'exit_price': price,
            'position_type': self.current_position.position_type,
            'pnl': pnl,
            'return': pnl / self.current_position.entry_price * 100
        })
        
        self.current_position = None
    
    def calculate_metrics(self):
        """
        Calculate portfolio performance metrics
        
        Returns:
            dict: Dictionary of performance metrics
        """
        if not self.trades:
            return {
                'total_return': 0.0,
                'win_rate': 0.0,
                'avg_return_per_trade': 0.0,
                'sharpe_ratio': 0.0,
                'max_drawdown': 0.0
            }
        
        # Calculate metrics
        total_return = (self.current_capital - self.initial_capital) / self.initial_capital * 100
        win_rate = self.winning_trades / self.trade_count * 100 if self.trade_count > 0 else 0
        avg_return_per_trade = np.mean([trade['return'] for trade in self.trades])
        
        # Calculate Sharpe ratio (assuming risk-free rate = 0)
        if len(self.daily_returns) > 1:
            returns_std = np.std(self.daily_returns)
            sharpe_ratio = np.mean(self.daily_returns) / returns_std * np.sqrt(252) if returns_std > 0 else 0
        else:
            sharpe_ratio = 0
        
        # Calculate maximum drawdown
        if len(self.daily_capital) > 0:
            cummax = np.maximum.accumulate(self.daily_capital)
            drawdown = (cummax - self.daily_capital) / cummax
            max_drawdown = np.max(drawdown) * 100 if len(drawdown) > 0 else 0
        else:
            max_drawdown = 0
        
        return {
            'total_return': total_return,
            'win_rate': win_rate,
            'avg_return_per_trade': avg_return_per_trade,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }

def get_stock_data(ticker, start_date, end_date):
    """
    Get historical stock data from Yahoo Finance
    
    Args:
        ticker (str): Stock ticker symbol
        start_date (str): Start date in YYYY-MM-DD format
        end_date (str): End date in YYYY-MM-DD format
        
    Returns:
        pd.DataFrame: DataFrame with OHLCV data
    """
    # Download data from Yahoo Finance
    data = yf.download(ticker, start=start_date, end=end_date)
    
    # Reset index to make Date a column
    data = data.reset_index()
    
    # Fix column names
    if isinstance(data.columns, pd.MultiIndex):
        # Handle multi-level columns
        data.columns = [f"{col[0]}_{ticker}" if col[0] != 'Date' else 'Date' for col in data.columns]
    else:
        # Handle single-level columns
        data.columns = [f"{col}_{ticker}" if col != 'Date' else 'Date' for col in data.columns]
    
    return data

def generate_sentiment_data(stock_data):
    """
    Generate simulated sentiment data
    
    Args:
        stock_data (pd.DataFrame): Stock data with dates
        
    Returns:
        pd.DataFrame: DataFrame with dates and sentiment scores
    """
    dates = stock_data['Date']
    n = len(dates)
    
    # Generate random sentiment scores with some autocorrelation
    ar_params = [0.7]  # AR(1) parameter
    ma_params = [0.2]  # MA(1) parameter
    ar = np.random.normal(0, 1, n)
    
    # Apply AR process
    for i in range(1, n):
        ar[i] += ar_params[0] * ar[i-1]
    
    # Apply MA process
    ma = np.random.normal(0, 0.5, n)
    for i in range(1, n):
        ar[i] += ma_params[0] * ma[i-1]
    
    # Normalize to mean 0, std 1
    sentiment_scores = (ar - np.mean(ar)) / np.std(ar)
    
    # Create DataFrame with proper dates
    sentiment_data = pd.DataFrame({
        'Date': dates,
        'sentiment_score': sentiment_scores
    })
    
    return sentiment_data

def calculate_technical_indicators(data):
    """
    Calculate technical indicators for the dataset
    
    Args:
        data (pd.DataFrame): Input data with OHLCV columns
        
    Returns:
        pd.DataFrame: Data with technical indicators added
    """
    df = data.copy()
    
    # Simple Moving Averages
    df['SMA_20'] = df['Close_AAPL'].rolling(window=20).mean()
    df['SMA_50'] = df['Close_AAPL'].rolling(window=50).mean()
    
    # Exponential Moving Averages
    df['EMA_20'] = df['Close_AAPL'].ewm(span=20, adjust=False).mean()
    df['EMA_50'] = df['Close_AAPL'].ewm(span=50, adjust=False).mean()
    
    # Relative Strength Index (RSI)
    delta = df['Close_AAPL'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    
    # MACD
    exp1 = df['Close_AAPL'].ewm(span=12, adjust=False).mean()
    exp2 = df['Close_AAPL'].ewm(span=26, adjust=False).mean()
    df['MACD'] = exp1 - exp2
    df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['MACD_hist'] = df['MACD'] - df['MACD_signal']
    
    # Bollinger Bands
    df['BB_middle'] = df['Close_AAPL'].rolling(window=20).mean()
    bb_std = df['Close_AAPL'].rolling(window=20).std()
    df['BB_upper'] = df['BB_middle'] + (bb_std * 2)
    df['BB_lower'] = df['BB_middle'] - (bb_std * 2)
    
    # Handle NaN values
    df = df.fillna(method='bfill')
    
    return df

def calculate_atr(data, period=14):
    """Calculate Average True Range"""
    high = data['High_AAPL']
    low = data['Low_AAPL']
    close = data['Close_AAPL']
    
    tr1 = high - low
    tr2 = abs(high - close.shift(1))
    tr3 = abs(low - close.shift(1))
    
    tr = pd.DataFrame({'tr1': tr1, 'tr2': tr2, 'tr3': tr3}).max(axis=1)
    atr = tr.rolling(window=period).mean()
    
    return atr

def calculate_bollinger_bands(data, period=20, std_dev=2):
    """Calculate Bollinger Bands"""
    sma = data['Close_AAPL'].rolling(window=period).mean()
    std = data['Close_AAPL'].rolling(window=period).std()
    
    upper_band = sma + (std * std_dev)
    lower_band = sma - (std * std_dev)
    
    return upper_band, lower_band

def calculate_rsi(data, period=14):
    """Calculate Relative Strength Index"""
    delta = data['Close_AAPL'].diff()
    
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    
    return rsi

def calculate_macd(data, fast=12, slow=26, signal=9):
    """Calculate MACD (Moving Average Convergence Divergence)"""
    ema_fast = data['Close_AAPL'].ewm(span=fast, adjust=False).mean()
    ema_slow = data['Close_AAPL'].ewm(span=slow, adjust=False).mean()
    
    macd = ema_fast - ema_slow
    macd_signal = macd.ewm(span=signal, adjust=False).mean()
    
    return macd, macd_signal

def prepare_dataset(stock_data, sentiment_data, window_size=20):
    """
    Prepare dataset for training
    
    Args:
        stock_data (pd.DataFrame): Stock price data
        sentiment_data (pd.DataFrame): Sentiment data
        window_size (int): Size of the lookback window
        
    Returns:
        tuple: (X, y) where X is the features and y is the labels
    """
    # Merge stock and sentiment data
    data = pd.merge(stock_data, sentiment_data, on='Date', how='inner')
    
    # Calculate technical indicators
    data = calculate_technical_indicators(data)
    
    # Drop rows with NaN values
    data = data.dropna()
    
    # Select features
    feature_columns = [
        'Close_AAPL', 'Volume_AAPL', 'sentiment_score',
        'SMA_20', 'SMA_50', 'EMA_20', 'EMA_50',
        'RSI', 'MACD', 'MACD_signal', 'MACD_hist',
        'BB_upper', 'BB_middle', 'BB_lower'
    ]
    
    # Create sequences
    X, y = [], []
    for i in range(len(data) - window_size):
        # Get window of features
        window = data[feature_columns].iloc[i:i+window_size].values
        
        # Check for NaN values in window
        if np.isnan(window).any():
            continue
            
        # Get target (1 if price goes up, 0 if down)
        target = 1 if data['Close_AAPL'].iloc[i+window_size] > data['Close_AAPL'].iloc[i+window_size-1] else 0
        
        X.append(window)
        y.append(target)
    
    # Convert to numpy arrays
    X = np.array(X)
    y = np.array(y)
    
    # Validate data
    if np.isnan(X).any():
        raise ValueError("Features contain NaN values after preparation")
    if np.isnan(y).any():
        raise ValueError("Labels contain NaN values after preparation")
    
    return X, y

class TradingSNN(Network):
    """
    Trading model using a Spiking Neural Network with LIF neurons and STDP learning
    """
    def __init__(self, input_size, hidden_size=64, output_size=1):
        """
        Initialize the SNN model with LIF neurons and STDP learning
        
        Args:
            input_size (tuple): Input dimensions (seq_len, n_features)
            hidden_size (int): Number of hidden neurons
            output_size (int): Number of output neurons (1 for binary classification)
        """
        super(TradingSNN, self).__init__()
        
        self.seq_len, self.n_features = input_size
        self.hidden_size = hidden_size
        self.output_size = output_size
        
        # Calculate flattened input size
        self.flat_size = self.seq_len * self.n_features
        
        # Create layers with LIF neurons
        input_layer = Input(n=self.flat_size)
        hidden_layer = LIFNodes(n=hidden_size, traces=True)  # Enable spike traces
        output_layer = LIFNodes(n=output_size, traces=True)  # Enable spike traces
        
        # Add layers to the network
        self.add_layer(input_layer, name='Input')
        self.add_layer(hidden_layer, name='Hidden')
        self.add_layer(output_layer, name='Output')
        
        # Create connections with STDP learning
        self.add_connection(Connection(source=input_layer, target=hidden_layer, w=tensor(0.05).repeat(self.flat_size, hidden_size)), source='Input', target='Hidden')
        self.add_connection(Connection(source=hidden_layer, target=output_layer, w=tensor(0.05).repeat(hidden_size, output_size)), source='Hidden', target='Output')
        
        # Add STDP learning rule
        self.add_connection(Connection(source=hidden_layer, target=output_layer, w=tensor(0.05).repeat(hidden_size, output_size), update_rule=PostPre, nu=0.01), source='Hidden', target='Output')
        
        # Monitor spikes and voltages
        self.add_monitor(Monitor(obj=hidden_layer, state_vars=['s', 'v'], time=1), name='HiddenMonitor')
        self.add_monitor(Monitor(obj=output_layer, state_vars=['s', 'v'], time=1), name='OutputMonitor')
    
    def prepare_input(self, X):
        """
        Prepare input data for the network
        
        Args:
            X (np.ndarray): Input features of shape (n_samples, seq_len, n_features)
            
        Returns:
            torch.Tensor: Prepared input tensor
        """
        # Ensure data is numeric and handle NaN values
        X = np.nan_to_num(X).astype(np.float32)
        
        # Convert to torch tensor
        X = torch.FloatTensor(X)
        
        # Normalize features
        mean = X.mean(dim=(0, 1), keepdim=True)
        std = X.std(dim=(0, 1), keepdim=True)
        X = (X - mean) / (std + 1e-8)
        
        return X
    
    def forward(self, x):
        """
        Forward pass through the network
        
        Args:
            x (torch.Tensor): Input tensor of shape (batch_size, seq_len, n_features)
            
        Returns:
            torch.Tensor: Output spikes
        """
        # Reshape input: (batch_size, seq_len, n_features) -> (batch_size, seq_len * n_features)
        batch_size = x.size(0)
        x = x.reshape(batch_size, -1)
        
        # Run the network for a single time step
        self.run(inputs={'Input': x}, time=1)
        
        # Get output spikes
        output_spikes = self.monitors['OutputMonitor'].get('s')
        
        return output_spikes
    
    def fit(self, X_train, y_train, epochs=10, batch_size=32):
        """
        Train the network using STDP
        
        Args:
            X_train (np.ndarray): Training features
            y_train (np.ndarray): Training labels
            epochs (int): Number of training epochs
            batch_size (int): Batch size
        """
        print("\nTraining SNN model for", epochs, "epochs...")
        
        # Prepare data
        X = self.prepare_input(X_train)
        y = torch.FloatTensor(y_train)
        
        # Create dataset and dataloader
        dataset = TensorDataset(X, y.unsqueeze(1))
        dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)
        
        # Training mode
        self.train()
        
        for epoch in range(epochs):
            total_loss = 0
            correct = 0
            total = 0
            
            for batch_X, batch_y in dataloader:
                # Forward pass
                self.run(inputs={'Input': batch_X}, time=1)
                
                # Get output spikes
                output_spikes = self.monitors['OutputMonitor'].get('s')
                
                # Calculate loss (using spikes as output)
                loss = self.criterion(output_spikes, batch_y)
                
                # Backward pass and optimize
                self.optimizer.zero_grad()
                loss.backward()
                self.optimizer.step()
                
                # Track metrics
                total_loss += loss.item()
                predicted = (output_spikes > 0.5).float()
                total += batch_y.size(0)
                correct += (predicted == batch_y).sum().item()
            
            # Calculate epoch metrics
            avg_loss = total_loss / len(dataloader)
            accuracy = 100 * correct / total
            
            # Print epoch statistics
            print(f"Epoch {epoch+1}/{epochs}, Loss: {avg_loss:.4f}, Accuracy: {accuracy:.4f}")
    
    def predict(self, X_test):
        """
        Make predictions on test data
        
        Args:
            X_test (np.ndarray): Test features
            
        Returns:
            tuple: (predictions, confidences)
        """
        # Prepare input
        X = self.prepare_input(X_test)
        
        # Evaluation mode
        self.eval()
        
        # Make predictions
        with torch.no_grad():
            self.run(inputs={'Input': X}, time=1)
            output_spikes = self.monitors['OutputMonitor'].get('s')
        
        # Get predictions and confidences
        predictions = (output_spikes > 0.5).float().numpy().squeeze()
        confidences = output_spikes.numpy().squeeze()
        
        return predictions, confidences

def evaluate_model(model, X, y):
    """
    Evaluate the model's performance.
    
    Args:
        model: The trained model
        X (np.ndarray): Test features
        y (np.ndarray): Test labels
        
    Returns:
        dict: Dictionary containing evaluation metrics
    """
    # Make predictions
    y_pred, confidences = model.predict(X)
    
    # Calculate metrics
    metrics = {
        'accuracy': accuracy_score(y, y_pred),
        'precision': precision_score(y, y_pred),
        'recall': recall_score(y, y_pred),
        'f1': f1_score(y, y_pred),
        'avg_confidence': np.mean(confidences),
        'high_conf_accuracy': accuracy_score(y[confidences > 0.7], y_pred[confidences > 0.7]) if any(confidences > 0.7) else 0
    }
    
    return metrics

class TradingStrategy:
    """
    Trading strategy implementation with position sizing and risk management
    """
    def __init__(self, initial_capital=100000, risk_per_trade=0.02):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.risk_per_trade = risk_per_trade  # Maximum risk per trade as percentage of capital
        self.position = None
        self.trades = []
        
    def calculate_position_size(self, confidence, price, stop_loss_pct=0.02):
        """
        Calculate position size based on confidence and risk management
        
        Args:
            confidence (float): Model's prediction confidence (0-1)
            price (float): Current price
            stop_loss_pct (float): Stop loss percentage
            
        Returns:
            float: Number of shares to trade
        """
        # Scale position size by confidence
        risk_amount = self.current_capital * self.risk_per_trade * confidence
        stop_loss_amount = price * stop_loss_pct
        
        # Calculate position size that risks the risk_amount given the stop loss
        position_size = risk_amount / stop_loss_amount
        
        # Round down to nearest whole share
        return int(position_size)
        
    def execute_trade(self, signal, confidence, price, timestamp):
        """
        Execute a trade based on the signal and current position
        
        Args:
            signal (int): 1 for buy, 0 for sell
            confidence (float): Model's prediction confidence
            price (float): Current price
            timestamp (pd.Timestamp): Current timestamp
            
        Returns:
            float: Profit/loss from the trade
        """
        profit = 0
        
        # Close existing position if signal differs
        if self.position is not None and signal != self.position['signal']:
            # Calculate profit/loss
            shares = self.position['shares']
            entry_price = self.position['entry_price']
            profit = shares * (price - entry_price)
            
            # Update capital
            self.current_capital += profit
            
            # Record trade
            self.trades.append({
                'entry_time': self.position['entry_time'],
                'exit_time': timestamp,
                'entry_price': entry_price,
                'exit_price': price,
                'shares': shares,
                'profit': profit,
                'return': profit / (shares * entry_price)
            })
            
            self.position = None
        
        # Open new position if none exists
        if self.position is None and confidence > 0.6:  # Only trade on high confidence
            shares = self.calculate_position_size(confidence, price)
            
            if shares > 0:
                self.position = {
                    'signal': signal,
                    'shares': shares,
                    'entry_price': price,
                    'entry_time': timestamp,
                    'stop_loss': price * (0.98 if signal == 1 else 1.02),  # 2% stop loss
                    'take_profit': price * (1.04 if signal == 1 else 0.96)  # 4% take profit
                }
        
        # Check stop loss and take profit for existing position
        elif self.position is not None:
            if (self.position['signal'] == 1 and 
                (price <= self.position['stop_loss'] or price >= self.position['take_profit'])):
                # Close long position
                profit = self.position['shares'] * (price - self.position['entry_price'])
                self.current_capital += profit
                
                self.trades.append({
                    'entry_time': self.position['entry_time'],
                    'exit_time': timestamp,
                    'entry_price': self.position['entry_price'],
                    'exit_price': price,
                    'shares': self.position['shares'],
                    'profit': profit,
                    'return': profit / (self.position['shares'] * self.position['entry_price'])
                })
                
                self.position = None
                
            elif (self.position['signal'] == 0 and 
                  (price >= self.position['stop_loss'] or price <= self.position['take_profit'])):
                # Close short position
                profit = self.position['shares'] * (self.position['entry_price'] - price)
                self.current_capital += profit
                
                self.trades.append({
                    'entry_time': self.position['entry_time'],
                    'exit_time': timestamp,
                    'entry_price': self.position['entry_price'],
                    'exit_price': price,
                    'shares': self.position['shares'],
                    'profit': profit,
                    'return': profit / (self.position['shares'] * self.position['entry_price'])
                })
                
                self.position = None
        
        return profit

def backtest_strategy(model, X_test, y_test, test_data, initial_capital=100000):
    """
    Backtest the trading strategy
    
    Args:
        model (TradingSNN): Trained model
        X_test (np.ndarray): Test features
        y_test (np.ndarray): Test labels
        test_data (pd.DataFrame): Test data with prices
        initial_capital (float): Initial capital
        
    Returns:
        tuple: (trades_df, metrics)
    """
    # Make predictions
    predictions, confidences = model.predict(X_test)
    
    # Initialize strategy
    strategy = TradingStrategy(initial_capital=initial_capital)
    
    # Run backtest
    for i in range(len(predictions)):
        price = test_data['Close_AAPL'].iloc[i]
        timestamp = test_data['Date'].iloc[i]
        
        # Execute trade
        strategy.execute_trade(predictions[i], confidences[i], price, timestamp)
    
    # Close any remaining position at the end
    if strategy.position is not None:
        final_price = test_data['Close_AAPL'].iloc[-1]
        final_timestamp = test_data['Date'].iloc[-1]
        strategy.execute_trade(1-strategy.position['signal'], 1.0, final_price, final_timestamp)
    
    # Create trades DataFrame
    trades_df = pd.DataFrame(strategy.trades)
    
    # Calculate metrics
    if len(trades_df) > 0:
        metrics = {
            'total_return': (strategy.current_capital - initial_capital) / initial_capital * 100,
            'win_rate': len(trades_df[trades_df['profit'] > 0]) / len(trades_df) * 100,
            'avg_return_per_trade': trades_df['return'].mean() * 100,
            'sharpe_ratio': trades_df['return'].mean() / trades_df['return'].std() * np.sqrt(252) if len(trades_df) > 1 else 0,
            'max_drawdown': calculate_max_drawdown(strategy.trades) * 100
        }
    else:
        metrics = {
            'total_return': 0,
            'win_rate': 0,
            'avg_return_per_trade': 0,
            'sharpe_ratio': 0,
            'max_drawdown': 0
        }
    
    return trades_df, metrics

def calculate_max_drawdown(trades):
    """
    Calculate maximum drawdown from trade history
    
    Args:
        trades (list): List of trade dictionaries
        
    Returns:
        float: Maximum drawdown as a percentage
    """
    if not trades:
        return 0
    
    # Calculate equity curve
    equity = [100000]  # Start with initial capital
    for trade in trades:
        equity.append(equity[-1] + trade['profit'])
    
    # Calculate running maximum
    running_max = np.maximum.accumulate(equity)
    
    # Calculate drawdowns
    drawdowns = (running_max - equity) / running_max
    
    return np.max(drawdowns)

def simulate_market_price(stock_data):
    """
    Simulate market prices using the enhanced market model with improved stability
    """
    # Initialize simulated prices with the first actual price
    initial_price = stock_data['Close_AAPL'].iloc[0]
    prices = [initial_price]
    
    # Get actual prices for comparison
    actual_prices = stock_data['Close_AAPL'].values
    
    # Calculate actual market volatility for calibration
    actual_returns = np.diff(actual_prices) / actual_prices[:-1]
    actual_daily_vol = np.std(actual_returns)
    
    # Simulation parameters (calibrated to actual volatility)
    base_volatility = actual_daily_vol * 0.5  # Base volatility from actual data
    momentum_factor = 0.15    # 15% momentum impact
    price_pull_factor = 0.08  # 8% pull towards actual price
    max_daily_move = actual_daily_vol * 3  # Cap at 3 standard deviations
    
    # Initialize market state
    market_sentiment = 0
    sentiment_memory = 0.8  # Memory factor for sentiment persistence
    
    # Run simulation
    for i in range(1, len(stock_data)):
        # Calculate dynamic volatility based on recent price movements
        recent_volatility = np.std(np.diff(prices[-20:]) / prices[-20:-1]) if len(prices) >= 20 else base_volatility
        current_volatility = min(base_volatility + recent_volatility * 0.5, actual_daily_vol * 1.5)
        
        # Update market sentiment with memory effect
        sentiment_impact = np.random.normal(0, 0.001)  # Small random sentiment changes
        market_sentiment = sentiment_memory * market_sentiment + (1 - sentiment_memory) * sentiment_impact
        
        # Calculate price movement components
        random_move = np.random.normal(market_sentiment, current_volatility)
        
        # Calculate momentum with bounds
        if len(prices) > 1:
            recent_return = (prices[-1] - prices[-2]) / prices[-2]
            momentum = np.clip(recent_return * momentum_factor, -actual_daily_vol, actual_daily_vol)
        else:
            momentum = 0
        
        # Calculate price gap and pull with bounds
        price_gap = (actual_prices[i] - prices[-1]) / prices[-1]
        pull = np.clip(price_gap * price_pull_factor, -actual_daily_vol, actual_daily_vol)
        
        # Combine movements and calculate new price
        total_move = np.clip(random_move + momentum + pull, -max_daily_move, max_daily_move)
        new_price = prices[-1] * (1 + total_move)
        
        # Add minimal volume impact
        volume_factor = stock_data['Volume_AAPL'].iloc[i] / stock_data['Volume_AAPL'].mean()
        volume_noise = np.random.normal(0, 0.0001 * volume_factor)
        new_price *= (1 + volume_noise)
        
        # Ensure price stays positive and within reasonable bounds
        new_price = max(0.1, min(new_price, prices[-1] * (1 + max_daily_move)))
        
        prices.append(new_price)
    
    return np.array(prices)

def plot_market_simulation(stock_data):
    """
    Plot market simulation with actual price for comparison
    """
    plt.figure(figsize=(15, 10))
    
    # Plot actual price
    plt.plot(stock_data.index, stock_data['Close_AAPL'], 
             label='Actual Price', color='black', linewidth=2)
    
    # Plot simulated price
    simulated_prices = simulate_market_price(stock_data)
    plt.plot(stock_data.index, simulated_prices, 
             label='Simulated Price', color='red', linewidth=2)
    
    plt.title('Market Price Simulation vs Actual Price')
    plt.xlabel('Date')
    plt.ylabel('Price ($)')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()

def calculate_simulation_metrics(actual_prices, simulated_prices):
    """
    Calculate key metrics comparing simulated prices to actual prices
    """
    # Ensure arrays are float type
    actual_prices = actual_prices.astype(float)
    simulated_prices = simulated_prices.astype(float)
    
    # Remove any infinite or NaN values
    mask = np.isfinite(actual_prices) & np.isfinite(simulated_prices)
    actual_prices = actual_prices[mask]
    simulated_prices = simulated_prices[mask]
    
    if len(actual_prices) == 0 or len(simulated_prices) == 0:
        print("Warning: No valid data points for metrics calculation")
        return None
    
    # Calculate metrics with error handling
    try:
        # Calculate MSE and derived metrics
        diff = actual_prices - simulated_prices
        mse = np.mean(diff ** 2)
        rmse = np.sqrt(mse) if mse > 0 else 0
        mae = np.mean(np.abs(diff))
        
        # Calculate correlation with error handling
        if np.std(actual_prices) > 0 and np.std(simulated_prices) > 0:
            correlation = np.corrcoef(actual_prices, simulated_prices)[0, 1]
        else:
            correlation = 0
        
        # Calculate directional accuracy
        actual_returns = np.diff(actual_prices)
        simulated_returns = np.diff(simulated_prices)
        valid_moves = (actual_returns != 0) & (simulated_returns != 0)
        if np.sum(valid_moves) > 0:
            directional_accuracy = np.mean(
                np.sign(actual_returns[valid_moves]) == np.sign(simulated_returns[valid_moves])
            )
        else:
            directional_accuracy = 0
        
        # Calculate volatility
        actual_volatility = np.std(actual_returns) if len(actual_returns) > 0 else 1
        simulated_volatility = np.std(simulated_returns) if len(simulated_returns) > 0 else 1
        volatility_ratio = simulated_volatility/actual_volatility if actual_volatility > 0 else 1
        
        # Print metrics
        print("\nSimulation Metrics:")
        print(f"Root Mean Square Error: ${rmse:.2f}")
        print(f"Mean Absolute Error: ${mae:.2f}")
        print(f"Correlation: {correlation:.3f}")
        print(f"Directional Accuracy: {directional_accuracy:.1%}")
        print(f"Volatility Ratio (Simulated/Actual): {volatility_ratio:.2f}")
        
        return {
            'rmse': rmse,
            'mae': mae,
            'correlation': correlation,
            'directional_accuracy': directional_accuracy,
            'volatility_ratio': volatility_ratio
        }
        
    except Exception as e:
        print(f"Error calculating metrics: {str(e)}")
        return None

def predict_next_price(current_price, recent_prices, recent_volumes, sentiment_score=None):
    """
    Predict the next price based on current market conditions
    
    Args:
        current_price (float): Current price
        recent_prices (list): List of recent prices (last 20 days)
        recent_volumes (list): List of recent volumes (last 20 days)
        sentiment_score (float, optional): Current sentiment score
        
    Returns:
        tuple: (predicted_price, confidence_interval)
    """
    # Calculate market conditions
    recent_returns = np.diff(recent_prices) / recent_prices[:-1]
    current_volatility = np.std(recent_returns) if len(recent_returns) > 0 else 0.01
    volume_factor = recent_volumes[-1] / np.mean(recent_volumes) if len(recent_volumes) > 0 else 1.0
    
    # Calculate momentum
    momentum = (recent_prices[-1] - recent_prices[0]) / recent_prices[0] if len(recent_prices) > 1 else 0
    
    # Calculate sentiment impact
    sentiment_impact = 0.001 * sentiment_score if sentiment_score is not None else 0
    
    # Calculate base price movement
    base_move = np.random.normal(0, current_volatility)
    
    # Combine factors
    total_move = base_move + 0.2 * momentum + sentiment_impact
    
    # Add volume impact
    volume_noise = np.random.normal(0, 0.0001 * volume_factor)
    total_move += volume_noise
    
    # Calculate predicted price
    predicted_price = current_price * (1 + total_move)
    
    # Calculate confidence interval (95%)
    confidence_interval = 1.96 * current_volatility * current_price
    
    return predicted_price, confidence_interval

def update_prediction_model(new_price, new_volume, sentiment_score=None):
    """
    Update the prediction model with new data
    
    Args:
        new_price (float): New price data
        new_volume (float): New volume data
        sentiment_score (float, optional): New sentiment score
    """
    # Update recent price history
    global recent_prices, recent_volumes
    recent_prices = recent_prices[1:] + [new_price]
    recent_volumes = recent_volumes[1:] + [new_volume]
    
    # Update market sentiment
    global market_sentiment
    if sentiment_score is not None:
        market_sentiment = 0.8 * market_sentiment + 0.2 * sentiment_score
    
    # Recalculate volatility
    global current_volatility
    recent_returns = np.diff(recent_prices) / recent_prices[:-1]
    current_volatility = np.std(recent_returns) if len(recent_returns) > 0 else 0.01

# Initialize global variables for real-time prediction
recent_prices = []
recent_volumes = []
market_sentiment = 0
current_volatility = 0.01

def initialize_prediction_model(initial_data, window_size=20):
    """
    Initialize the prediction model with historical data
    
    Args:
        initial_data (pd.DataFrame): Historical price and volume data
        window_size (int): Size of the lookback window
    """
    global recent_prices, recent_volumes, market_sentiment, current_volatility
    
    # Initialize price and volume history
    recent_prices = list(initial_data['Close_AAPL'].tail(window_size))
    recent_volumes = list(initial_data['Volume_AAPL'].tail(window_size))
    
    # Initialize market sentiment
    market_sentiment = 0
    
    # Calculate initial volatility
    returns = np.diff(recent_prices) / recent_prices[:-1]
    current_volatility = np.std(returns) if len(returns) > 0 else 0.01

def plot_real_time_predictions(actual_prices, predicted_prices, confidence_intervals, days_ahead=5):
    """
    Plot real-time predictions with confidence intervals
    
    Args:
        actual_prices (list): List of actual prices
        predicted_prices (list): List of predicted prices
        confidence_intervals (list): List of confidence intervals
        days_ahead (int): Number of days to predict ahead
    """
    plt.figure(figsize=(15, 8))
    
    # Create x-axis labels
    x_actual = range(len(actual_prices))
    x_pred = range(len(actual_prices), len(actual_prices) + days_ahead)
    
    # Plot actual prices
    plt.plot(x_actual, actual_prices, 'b-', label='Actual Price', linewidth=2)
    
    # Plot predicted prices with confidence intervals
    plt.plot(x_pred, predicted_prices, 'r--', label='Predicted Price', linewidth=2)
    plt.fill_between(x_pred, 
                    [p - c for p, c in zip(predicted_prices, confidence_intervals)],
                    [p + c for p, c in zip(predicted_prices, confidence_intervals)],
                    color='r', alpha=0.2, label='95% Confidence Interval')
    
    # Add vertical line at current time
    plt.axvline(x=len(actual_prices)-1, color='g', linestyle='--', label='Current Time')
    
    plt.title('Real-Time Price Predictions')
    plt.xlabel('Time (days)')
    plt.ylabel('Price ($)')
    plt.legend()
    plt.grid(True)
    
    # Add price labels
    for i, (actual, pred) in enumerate(zip(actual_prices[-5:], predicted_prices)):
        plt.annotate(f'${actual:.2f}', 
                    (len(actual_prices)-5+i, actual),
                    textcoords="offset points", xytext=(0,10), ha='center')
        plt.annotate(f'${pred:.2f}', 
                    (len(actual_prices)+i, pred),
                    textcoords="offset points", xytext=(0,10), ha='center')
    
    plt.tight_layout()
    plt.savefig('real_time_predictions.png')
    plt.close()

class SNNTrader:
    """
    Trader that uses a Spiking Neural Network to make trading decisions
    """
    def __init__(self, model, initial_capital=10000):
        self.model = model
        self.capital = initial_capital
        self.position = None

    def decide(self, market_data):
        # Select only numeric columns for prediction
        numeric_data = market_data.select_dtypes(include=[np.number])
        
        # Prepare data for prediction
        X = numeric_data[-20:].values  # Convert to NumPy array
        X = X.flatten().reshape(1, -1)  # Flatten and reshape for model input

        # Ensure the input size matches the network's expected input size
        expected_size = self.model.flat_size
        if X.shape[1] != expected_size:
            raise ValueError(f"Input size {X.shape[1]} does not match expected size {expected_size}.")

        # Make prediction
        prediction, confidence = self.model.predict(X)

        # Select the first element if prediction is multi-dimensional
        if isinstance(prediction, np.ndarray) and prediction.size > 1:
            prediction_value = prediction[0]
        else:
            prediction_value = prediction.item() if isinstance(prediction, np.ndarray) else prediction

        # Decide based on prediction
        if prediction_value > 0.5:
            return 'buy', confidence
        else:
            return 'sell', confidence

    def execute_trade(self, decision, price):
        if decision == 'buy' and self.capital > price:
            self.position = price
            self.capital -= price
        elif decision == 'sell' and self.position is not None:
            self.capital += price
            self.position = None

class SignalTrader:
    """
    Trader that uses technical signals to make trading decisions
    """
    def __init__(self, initial_capital=10000):
        self.capital = initial_capital
        self.position = None

    def decide(self, market_data):
        # Example signal: Moving Average Crossover
        short_ma = market_data['Close_AAPL'].rolling(window=5).mean().iloc[-1]
        long_ma = market_data['Close_AAPL'].rolling(window=20).mean().iloc[-1]

        if short_ma > long_ma:
            return 'buy'
        else:
            return 'sell'

    def execute_trade(self, decision, price):
        if decision == 'buy' and self.capital > price:
            self.position = price
            self.capital -= price
        elif decision == 'sell' and self.position is not None:
            self.capital += price
            self.position = None

class RandomTrader:
    """
    Trader that makes random trading decisions
    """
    def __init__(self, initial_capital=10000):
        self.capital = initial_capital
        self.position = None

    def decide(self):
        return random.choice(['buy', 'sell'])

    def execute_trade(self, decision, price):
        if decision == 'buy' and self.capital > price:
            self.position = price
            self.capital -= price
        elif decision == 'sell' and self.position is not None:
            self.capital += price
            self.position = None


def simulate_market(traders, market_data, days=100):
    """
    Simulate the market with a set of traders
    """
    prices = [market_data['Close_AAPL'].iloc[-1]]  # Start with the last known price

    for day in range(days):
        daily_trades = []

        for trader in traders:
            if isinstance(trader, SNNTrader):
                decision, confidence = trader.decide(market_data)
            elif isinstance(trader, SignalTrader):
                decision = trader.decide(market_data)
            else:
                decision = trader.decide()

            price = prices[-1]  # Current market price
            trader.execute_trade(decision, price)
            daily_trades.append((decision, price))

        # Update market price based on trades
        buy_pressure = sum(1 for decision, _ in daily_trades if decision == 'buy')
        sell_pressure = sum(1 for decision, _ in daily_trades if decision == 'sell')

        # Simple price update rule
        if buy_pressure > sell_pressure:
            new_price = prices[-1] * (1 + 0.01)  # Increase by 1%
        elif sell_pressure > buy_pressure:
            new_price = prices[-1] * (1 - 0.01)  # Decrease by 1%
        else:
            new_price = prices[-1]  # No change

        prices.append(new_price)

    return prices


def main():
    # Get stock data
    stock_data = get_stock_data('AAPL', '2019-01-01', '2024-12-31')
    
    # Generate sentiment data
    sentiment_data = generate_sentiment_data(stock_data)
    
    # Merge data
    market_data = pd.merge(stock_data, sentiment_data, on='Date', how='inner').dropna() # Ensure no NaNs after merge
    
    # --- Simulation for Historical Comparison ---
    if len(market_data) > 100:
        # Split data
        data_for_simulation_setup = market_data.iloc[:-100]
        actual_last_100_days_data = market_data.iloc[-100:]
        actual_prices_last_100 = actual_last_100_days_data['Close_AAPL'].values
        actual_dates_last_100 = actual_last_100_days_data['Date'].values

        # Initialize traders using data before the last 100 days
        numeric_cols_count = len(data_for_simulation_setup.select_dtypes(include=[np.number]).columns)
        # Ensure SNN model input size matches the features used in simulation setup data
        snn_model_hist = TradingSNN(input_size=(20, numeric_cols_count)) 

        # Re-initialize traders for this specific simulation
        traders_hist = [SNNTrader(snn_model_hist) for _ in range(100)] + \
                       [SignalTrader() for _ in range(100)] + \
                       [RandomTrader() for _ in range(100)]

        # Simulate the last 100 days starting from the state before that period
        # Pass the data *before* the target period to simulate_market
        simulated_prices_last_100 = simulate_market(traders_hist, data_for_simulation_setup, days=100)
        
        # Plot historical comparison
        plt.figure(figsize=(15, 7))
        plt.plot(actual_dates_last_100, actual_prices_last_100, label='Actual Price (Last 100 Days)', color='blue', linewidth=2)
        # Make sure simulated prices length matches actual dates (simulate_market returns initial price + 100 days)
        if len(simulated_prices_last_100) == 101:
             # Use the simulated prices (excluding the initial seed price) against the actual dates
             plt.plot(actual_dates_last_100, simulated_prices_last_100[1:], label='Simulated Price (Same Period)', color='red', linestyle='--', linewidth=2)
        else:
             print(f"Warning: Simulated prices length ({len(simulated_prices_last_100)}) mismatch. Expected 101. Skipping plot.")

        plt.title('Historical Simulation vs. Actual Price (Last 100 Days)')
        plt.xlabel('Date')
        plt.ylabel('Price ($)')
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        plt.savefig('historical_simulation_vs_actual.png')
        print("Historical simulation vs actual price plot saved to historical_simulation_vs_actual.png")
    else:
        print("Not enough data to perform historical simulation comparison (need > 100 days).")

    # --- Original Forward Simulation (Commented out) ---
    # snn_model_fwd = TradingSNN(input_size=(20, len(market_data.select_dtypes(include=[np.number]).columns)))
    # traders_fwd = [SNNTrader(snn_model_fwd) for _ in range(100)] + [SignalTrader() for _ in range(100)] + [RandomTrader() for _ in range(100)]
    # simulated_prices_fwd = simulate_market(traders_fwd, market_data, days=100)
    # print(f"Final forward simulated price after 100 days: {simulated_prices_fwd[-1]:.2f}")
    # actual_prices_to_plot = stock_data['Close_AAPL'].iloc[-100:].values
    # actual_dates = stock_data['Date'].iloc[-100:].values
    # actual_index = range(-100, 0)
    # simulated_index = range(0, len(simulated_prices_fwd))
    # plt.figure(figsize=(15, 7))
    # plt.plot(actual_index, actual_prices_to_plot, label='Actual Price (Last 100 Days)', color='blue')
    # plt.plot(simulated_index, simulated_prices_fwd, label='Simulated Market Price (Next 100 Days)', color='red', linestyle='--')
    # plt.title('Actual vs. Forward Simulated Market Dynamics')
    # plt.xlabel('Days (0 = Simulation Start)')
    # plt.ylabel('Price ($)')
    # plt.axvline(x=0, color='grey', linestyle=':', label='Simulation Start')
    # plt.legend()
    # plt.grid(True)
    # plt.tight_layout()
    # plt.savefig('actual_vs_forward_simulated_market_dynamics.png')
    # print("Actual vs. Forward simulated market dynamics plot saved to actual_vs_forward_simulated_market_dynamics.png")

if __name__ == "__main__":
    main()
